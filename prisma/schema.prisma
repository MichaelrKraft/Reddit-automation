generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  String               @id @default(cuid())
  clerkId             String               @unique
  email               String               @unique
  plan                String               @default("free")
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  hasLifetimeDeal     Boolean              @default(false)
  lifetimePurchasedAt DateTime?
  signupNumber        Int?
  stripeCustomerId    String?
  stripePaymentId     String?
  tier                UserTier             @default(ALPHA)
  brandKeywords       BrandKeyword[]
  draftPosts          DraftPost[]
  monitoredSubreddits MonitoredSubreddit[]
  opportunities       Opportunity[]
  opportunityActions  OpportunityAction[]
  redditAccounts      RedditAccount[]
  spyAccounts         SpyAccount[]
}

model RedditAccount {
  id                String       @id @default(cuid())
  username          String
  connected         Boolean      @default(true)
  karma             Int          @default(0)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  isWarmupAccount   Boolean      @default(false)
  userId            String
  warmupCompletedAt DateTime?
  warmupProgress    Json?
  warmupStartedAt   DateTime?
  warmupStatus      WarmupStatus @default(NOT_STARTED)
  campaigns         Campaign[]
  posts             Post[]
  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, username])
}

model Campaign {
  id          String        @id @default(cuid())
  name        String
  description String?
  status      String        @default("active")
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  accountId   String
  account     RedditAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  posts       Post[]
}

model Subreddit {
  id          String   @id @default(cuid())
  name        String   @unique
  displayName String
  subscribers Int      @default(0)
  relevance   Float    @default(0)
  lastChecked DateTime @default(now())
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  posts       Post[]
}

model Post {
  id           String         @id @default(cuid())
  title        String
  content      String
  postType     String         @default("text")
  status       String         @default("scheduled")
  scheduledAt  DateTime?
  postedAt     DateTime?
  redditId     String?        @unique
  url          String?
  firstComment String?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  accountId    String
  campaignId   String?
  subredditId  String
  comments     Comment[]
  account      RedditAccount  @relation(fields: [accountId], references: [id], onDelete: Cascade)
  campaign     Campaign?      @relation(fields: [campaignId], references: [id])
  subreddit    Subreddit      @relation(fields: [subredditId], references: [id], onDelete: Cascade)
  analytics    PostAnalytics?
}

model PostAnalytics {
  id           String   @id @default(cuid())
  upvotes      Int      @default(0)
  downvotes    Int      @default(0)
  score        Int      @default(0)
  commentCount Int      @default(0)
  engagement   Float    @default(0)
  lastUpdated  DateTime @default(now())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  postId       String   @unique
  post         Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model Comment {
  id        String   @id @default(cuid())
  redditId  String   @unique
  content   String
  author    String
  replied   Boolean  @default(false)
  replyText String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  postId    String
  post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
}

model SubredditActivity {
  id             String   @id @default(cuid())
  subredditName  String
  dayOfWeek      Int
  hourOfDay      Int
  avgScore       Float    @default(0)
  avgComments    Float    @default(0)
  postCount      Int      @default(0)
  engagementRate Float    @default(0)
  sampleSize     Int      @default(0)
  lastAnalyzed   DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  @@unique([subredditName, dayOfWeek, hourOfDay])
  @@index([subredditName])
}

model OptimalTimeRecommendation {
  id              String   @id @default(cuid())
  subredditName   String
  dayOfWeek       Int
  hourOfDay       Int
  confidenceScore Float    @default(0)
  avgEngagement   Float    @default(0)
  rank            Int      @default(0)
  calculatedAt    DateTime @default(now())
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@unique([subredditName, rank])
  @@index([subredditName])
}

model MonitoredSubreddit {
  id                       String         @id @default(cuid())
  subreddit                String
  isActive                 Boolean        @default(true)
  lastPostId               String?
  lastChecked              DateTime       @default(now())
  checkInterval            Int            @default(15)
  createdAt                DateTime       @default(now())
  updatedAt                DateTime       @updatedAt
  userId                   String
  lastOpportunityScan      DateTime?
  opportunityFrequency     String         @default("daily")
  opportunityMiningEnabled Boolean        @default(false)
  alerts                   AlertHistory[]
  user                     User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, subreddit])
  @@index([isActive])
  @@index([opportunityMiningEnabled])
}

model AlertHistory {
  id                   String             @id @default(cuid())
  postId               String
  postTitle            String
  postUrl              String
  postAuthor           String?
  subreddit            String
  commentOptions       String
  wasActedOn           Boolean            @default(false)
  responseTime         Int?
  alertType            String             @default("new_post")
  brandKeyword         String?
  contextSnippet       String?
  mentionType          String?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  monitoredSubredditId String
  monitoredSubreddit   MonitoredSubreddit @relation(fields: [monitoredSubredditId], references: [id], onDelete: Cascade)

  @@index([subreddit])
  @@index([createdAt])
  @@index([alertType])
  @@index([brandKeyword])
}

model BrandKeyword {
  id            String   @id @default(cuid())
  keyword       String
  isActive      Boolean  @default(true)
  lastMentionId String?
  alertCount    Int      @default(0)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, keyword])
  @@index([isActive])
}

model ViralPattern {
  id              String   @id @default(cuid())
  subreddit       String   @unique
  avgTitleLength  Float
  firstPersonRate Float
  questionRate    Float
  avgScore        Int
  contentType     String
  topWords        String
  formula         String
  exampleTitle    String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([subreddit])
}

model DraftPost {
  id             String   @id @default(cuid())
  title          String
  content        String?
  subreddit      String
  postType       String
  viralScore     Int
  scoreBreakdown String
  suggestions    String
  improvedTitles String
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  userId         String?
  user           User?    @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([viralScore])
  @@index([subreddit])
}

model SpyAccount {
  id          String       @id @default(cuid())
  username    String
  displayName String?
  avatarUrl   String?
  totalKarma  Int          @default(0)
  accountAge  DateTime?
  isActive    Boolean      @default(true)
  lastPostId  String?
  lastChecked DateTime     @default(now())
  notes       String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  alerts      SpyAlert[]
  insights    SpyInsight[]
  posts       SpyPost[]

  @@unique([userId, username])
  @@index([userId, isActive])
}

model SpyPost {
  id           String     @id @default(cuid())
  redditId     String
  title        String
  content      String?
  url          String
  subreddit    String
  postType     String
  score        Int        @default(0)
  upvoteRatio  Float      @default(0)
  commentCount Int        @default(0)
  awards       Int        @default(0)
  postedAt     DateTime
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  accountId    String
  account      SpyAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([accountId, redditId])
  @@index([accountId, postedAt])
  @@index([subreddit])
  @@index([score])
}

model SpyAlert {
  id          String     @id @default(cuid())
  alertType   String
  title       String
  description String
  postUrl     String?
  subreddit   String?
  isRead      Boolean    @default(false)
  createdAt   DateTime   @default(now())
  accountId   String
  account     SpyAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId, isRead])
}

model SpyInsight {
  id          String     @id @default(cuid())
  insightType String
  title       String
  description String
  actionItems String
  confidence  Float      @default(0.8)
  createdAt   DateTime   @default(now())
  accountId   String
  account     SpyAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([accountId])
}

model Opportunity {
  id               String                 @id @default(cuid())
  title            String
  category         OpportunityCategory
  score            Int
  problemStatement String
  evidenceCount    Int                    @default(0)
  firstSeenAt      DateTime               @default(now())
  lastUpdatedAt    DateTime               @default(now())
  trendDirection   TrendDirection         @default(STABLE)
  status           OpportunityStatus      @default(NEW)
  metadata         Json?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  userId           String
  user             User                   @relation(fields: [userId], references: [id], onDelete: Cascade)
  actions          OpportunityAction[]
  evidence         OpportunityEvidence[]
  subreddits       OpportunitySubreddit[]

  @@index([userId, score])
  @@index([userId, status])
  @@index([category])
  @@index([createdAt])
}

model OpportunityEvidence {
  id             String      @id @default(cuid())
  redditPostId   String
  redditPostUrl  String
  quoteText      String
  author         String?
  subreddit      String
  upvotes        Int         @default(0)
  commentCount   Int         @default(0)
  sentimentScore Float?
  postedAt       DateTime
  createdAt      DateTime    @default(now())
  opportunityId  String
  opportunity    Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)

  @@unique([redditPostId, opportunityId])
  @@index([opportunityId])
  @@index([subreddit])
  @@index([postedAt])
}

model OpportunitySubreddit {
  id               String      @id @default(cuid())
  subreddit        String
  mentionCount     Int         @default(1)
  firstMentionedAt DateTime    @default(now())
  lastMentionedAt  DateTime    @default(now())
  opportunityId    String
  opportunity      Opportunity @relation(fields: [opportunityId], references: [id], onDelete: Cascade)

  @@unique([opportunityId, subreddit])
  @@index([opportunityId])
}

model OpportunityAction {
  id            String                @id @default(cuid())
  actionType    OpportunityActionType
  metadata      Json?
  createdAt     DateTime              @default(now())
  opportunityId String
  userId        String
  opportunity   Opportunity           @relation(fields: [opportunityId], references: [id], onDelete: Cascade)
  user          User                  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([opportunityId])
  @@index([userId, createdAt])
}

model Waitlist {
  id           String    @id @default(cuid())
  email        String    @unique
  name         String?
  referralCode String?
  position     Int
  notified     Boolean   @default(false)
  convertedAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([position])
  @@index([createdAt])
}

enum UserTier {
  FOUNDER
  ALPHA
  STANDARD
}

enum WarmupStatus {
  NOT_STARTED
  PHASE_1_UPVOTES
  PHASE_2_COMMENTS
  PHASE_3_POSTS
  PHASE_4_MIXED
  COMPLETED
  PAUSED
  FAILED
}

enum OpportunityCategory {
  PAIN_POINT
  FEATURE_REQUEST
  CONTENT_OPPORTUNITY
  COMPETITOR_GAP
  TRENDING_TOPIC
}

enum OpportunityStatus {
  NEW
  TRACKING
  ACTED_ON
  ARCHIVED
}

enum TrendDirection {
  GROWING
  STABLE
  DECLINING
}

enum OpportunityActionType {
  VIEWED
  CONTENT_CREATED
  TRACKED
  EXPORTED
  ARCHIVED
}

model AlphaFeedback {
  id        String   @id @default(cuid())
  clerkId   String?
  type      String   @default("general")
  message   String
  name      String?
  email     String?
  page      String?
  userAgent String?
  status    String   @default("new")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([clerkId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
}

model DripEmail {
  id        String   @id @default(cuid())
  userId    String
  emailType String   // welcome, gettingStarted, tips, caseStudy, feature, checkIn
  sentAt    DateTime @default(now())
  resendId  String?  // Resend message ID for tracking

  @@unique([userId, emailType])
  @@index([userId])
  @@index([emailType])
}
